

<script src="/assets/sceneFunctions.js"></script>

<h1>02 - Механика - Гравитация</h1> 

<%- include('../components/gravity-tabs.html', {active: 'main'}); %> 

<article class="grid"> 

    <div id="sim-wrapper" class="s9">
        <div id="physicsInfo">
            <div>Time: <span id="timeValue">0.00</span></div>
            <div>Distance: <span id="distanceValue">0.0</span></div>
            <div>Min Distance: <span id="minDistanceValue">0.0</span></div>
            <div>Max Distance: <span id="maxDistanceValue">0.0</span></div>
            <div>R1: <span id="r1Value">0.0</span></div>
            <div>R2: <span id="r2Value">0.0</span></div>
        </div>

        <div id="sim-container"></div>
    </div>

    <div class="inputs s3">
        <fieldset>
            <button onclick="runSimulation()">Start Simulation</button>
        </fieldset>
        <fieldset>
            <div class="row">
                <div class="max">
                    <div class="field border label max">
                        <input type="number" id="mass1" min="0" max="1000000" value="200" step="0.1">
                        <label>Mass 1</label>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="max">
                    <div class="field border label max">
                        <input type="number" id="mass2" min="0" max="10000000" value="100" step="0.1">
                        <label>Mass 2</label>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="max">
                    <div class="field border label max">
                        <input type="number" id="distance" min="0" max="100" value="10" step="0.1">
                        <label>Distance</label>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="max">
                    <div class="field border label max">
                        <input type="number" id="velocity1" min="0" max="100" value="1.5" step="0.1">
                        <label>Velocity 1</label>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="max">
                    <div class="field border label max">
                        <input type="number" id="velocity2" min="0" max="100" value="2.5" step="0.1">
                        <label>Velocity 2</label>
                    </div>
                </div>
            </div>
        </fieldset>
    </div>
</article>

<article class="description-text page active">
    <h3>Описание</h3>
    <p>В этой симуляции мы моделируем гравитационное взаимодействие между двумя массами в трехмерном пространстве.
        Пользователь может задавать массу, начальную скорость и расстояние между двумя объектами. 
        Симуляция демонстрирует, как гравитационные силы влияют на движение объектов с течением времени.</p>
    <p>Используемые концепции включают законы Ньютона о движении и гравитации, а также основы векторной математики для расчета сил и ускорений.</p>
    <p>Симуляция позволяет наблюдать за орбитальным движением, столкновениями и другими динамическими эффектами, возникающими из-за гравитационного взаимодействия.</p>
   <h5>Некоторые важные определения</h5>
   <p>Масса (mass) - это мера инертности тела, определяющая его сопротивление изменению движения.</p>
   <p>Расстояние (distance) - это мера пространства между двумя точками.</p>
   <p>Скорость (velocity) - это векторная величина, определяющая изменение положения тела с течением времени.</p>
   <p>Радиус (radius) - это расстояние от центра тела до поверхности.</p>
   <p>Гравитация (gravity) - это сила притяжения между двумя массами, пропорциональная произведению их масс и
    обратно пропорциональная квадрату расстояния между ними.</p>
    
    <p>Гравитационная постоянная (G) - это физическая константа, которая используется для описания силы гравитационного
        притяжения между двумя объектами. Ее значение составляет примерно \(6.674 \times 10^{-11} \, \text{м}^3/\text{кг} \cdot \text{с}^2\).
        В данной симуляции для визуализации взаимодействия используется значение G = 1.
    </p>


    <h5>Формулы</h5>
    <p>Сила гравитационного притяжения (Закон Всемирной гравитации):</p>
    <p>
        \[F = G \cdot (m1 \cdot m2) / r^2\]
    </p>где G - гравитационная постоянная, m1 и m2 - массы объектов, r - расстояние между ними.</p>

</article>

<script>
    const vars = {
        fps: 60,
        time: 0,
        isMoving: false,
        mass1: 200,
        mass2: 100,
        r1: 2,
        r2: 1,
        distance: 15,
        velocity1: 1.5,
        velocity2: -2.5,
    };
    const viewSize = 800;
    const gridConfig = {
        size: 200,
        divisions: 50,
        colorCenterLine: 0x000000,
        colorGrid: 0x444444
    };
    const statValues = {
        minDistance: 0,
        maxDistance: 0,
    };

    // Инициализация сцены, камеры и рендерера
    const scene = new THREE.Scene();
    const camera = createCamera();
    const renderer = createRenderer();
    document.querySelector('#sim-container').appendChild(renderer.domElement);

    // Добавление освещения
    const lights = createLights();
    scene.add(lights.ambientLight);
    scene.add(lights.directionalLight);
    
    // Добавление координатной сетки
    let gridHelper;
    createGrid();

    // добавление планеты 1
    const objGeometry1 = new THREE.SphereGeometry(vars.r1, 32, 32);
    const objTexture1 = new THREE.TextureLoader().load('/assets/mercury.jpg');
    const objMaterial1 = new THREE.MeshStandardMaterial({
        map: objTexture1,
        roughness: 0.8,
        metalness: 0.1,
        normalScale: new THREE.Vector2(1, 1)
    });
    const obj1 = new THREE.Mesh(objGeometry1, objMaterial1);
    obj1.castShadow = true; // Включаем тени
    scene.add(obj1);
    let velocity1 = new THREE.Vector3(0, 0, 0);

    // добавление планеты 2
    const objGeometry2 = new THREE.SphereGeometry(vars.r2, 32, 32);
    const objTexture2 = new THREE.TextureLoader().load('/assets/mercury.jpg');
    const objMaterial2 = new THREE.MeshLambertMaterial({
        map: objTexture2,
        color: 0xff3456,
        fog: true,
        reflectivity: 1,
        refractionRatio: 0.1,
    });
    const obj2 = new THREE.Mesh(objGeometry2, objMaterial2);
    obj2.castShadow = true; // Включаем тени
    scene.add(obj2);
    let velocity2 = new THREE.Vector3(0, 0, 0);
    let maxDistance = 0;

    // Используем улучшенные трейлы
    const advancedTrails = {
        obj1: createAdvancedTrail(0x00ccff, 1000), // Красный, 1000 точек
        obj2: createAdvancedTrail(0xff3456, 1000)  // Синий, 1000 точек
    };

    scene.add(advancedTrails.obj1.line);
    scene.add(advancedTrails.obj2.line);


    function setup() {
        vars.mass1 = parseFloat(document.getElementById('mass1').value);
        vars.mass2 = parseFloat(document.getElementById('mass2').value);
        vars.distance = parseFloat(document.getElementById('distance').value);
        vars.velocity1 = parseFloat(document.getElementById('velocity1').value);
        vars.velocity2 = -parseFloat(document.getElementById('velocity2').value);
        vars.r1 = Math.cbrt(vars.mass1) * 0.2; // Радиус пропорционален кубическому корню массы
        vars.r2 = Math.cbrt(vars.mass2) * 0.2;
        camera.position.set(-10, vars.distance * 2, 0);
        camera.lookAt(0, 0, 0);
        obj1.position.x = 0;
        obj1.position.z = -vars.distance / 2;
        obj1.radius = vars.r1;
        obj1.geometry = new THREE.SphereGeometry(vars.r1, 32, 32);
        obj2.position.x = 0;
        obj2.position.z = vars.distance / 2;
        obj2.radius = vars.r2;
        obj2.geometry = new THREE.SphereGeometry(vars.r2, 32, 32);
        clearTrails();
        statValues.minDistance = 0;
        statValues.maxDistance = 0;
    }

    // Добавим возможность сброса анимации по клику
    function runSimulation() {
        setup();
        vars.time = 0;
        vars.isMoving = true;
        velocity1.set(vars.velocity1, 0, 0);
        velocity2.set(vars.velocity2, 0, 0);
        obj1.position.set(0, 0, -(vars.distance / 2));
        obj2.position.set(0, 0, (vars.distance / 2));
    }

    // Улучшенная функция создания трейла
    function createAdvancedTrail(color, maxPoints = 500) {
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.LineBasicMaterial({
            color: color,
            linewidth: 1,
            transparent: true,
            opacity: 0.3,
            depthTest: false
        });
        
        const positions = new Float32Array(maxPoints * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        return {
            line: new THREE.Line(geometry, material),
            points: [],
            maxPoints: maxPoints,
            addPoint: function(position) {
                this.points.push(position.clone());
                if (this.points.length > this.maxPoints) {
                    this.points.shift();
                }
                this.updateGeometry();
            },
            updateGeometry: function() {
                const positions = this.line.geometry.attributes.position.array;
                for (let i = 0; i < this.points.length; i++) {
                    positions[i * 3] = this.points[i].x;
                    positions[i * 3 + 1] = this.points[i].y;
                    positions[i * 3 + 2] = this.points[i].z;
                }
                this.line.geometry.attributes.position.needsUpdate = true;
                this.line.geometry.setDrawRange(0, this.points.length);
            },
            clear: function() {
                this.points = [];
                this.updateGeometry();
            }
        };
    }

    // Функция анимации
    function animate() {
        requestAnimationFrame(animate);

        const deltaTime = (vars.fps > 0 ? 1 / vars.fps : 0.016);

        if (vars.isMoving) {
            vars.time += deltaTime;
            const G = 1; // Гравитационная постоянная (упрощенная для симуляции)
            const r = obj2.position.clone().sub(obj1.position);
            vars.distance = r.length();
            const distance = vars.distance;
            maxDistance = Math.max(maxDistance, distance);

            if (distance > obj1.geometry.parameters.radius + obj2.geometry.parameters.radius) { // Предотвращаем слишком близкое сближение
                const forceMagnitude = (G * vars.mass1 * vars.mass2) / (distance * distance);
                const force = r.normalize().multiplyScalar(forceMagnitude);

                // Обновление позиций на основе силы
                const acceleration1 = force.clone().divideScalar(vars.mass1);
                const acceleration2 = force.clone().negate().divideScalar(vars.mass2);

                velocity1.add(acceleration1.multiplyScalar(deltaTime));
                velocity2.add(acceleration2.multiplyScalar(deltaTime));

                obj1.position.add(velocity1.clone().multiplyScalar(deltaTime));
                obj2.position.add(velocity2.clone().multiplyScalar(deltaTime));

                // Обновляем трейлы (реже для оптимизации)
                if (Math.floor(vars.time * 10) % 2 === 0) {
                    advancedTrails.obj1.addPoint(obj1.position.clone());
                    advancedTrails.obj2.addPoint(obj2.position.clone());
                }

                camera.position.set(-10, maxDistance + 10, 0);
                camera.lookAt((obj1.position.x + obj2.position.x) / 2, 0, (obj1.position.z + obj2.position.z) / 2);

            } else {
                vars.isMoving = false; // Остановить движение при слишком близком сближении
                console.log('Objects have collided or are too close. Simulation stopped.');
            }
            updateTelemetry();
        }

        renderer.render(scene, camera);
    }

    function clearTrails() {
        advancedTrails.obj1.clear();
        advancedTrails.obj2.clear();
    }

    function clearTrailsSimple() {
        [trails.obj1, trails.obj2].forEach(trail => {
            const newGeometry = new THREE.BufferGeometry();
            trail.geometry.dispose();
            trail.geometry = newGeometry;
        });
    }

    function updateTelemetry() {
        document.getElementById('timeValue').innerText = vars.time.toFixed(2);
        const distance = obj1.position.distanceTo(obj2.position);
        document.getElementById('distanceValue').innerText = distance.toFixed(2);
        statValues.minDistance = statValues.minDistance === 0 ? distance : Math.min(statValues.minDistance, distance);
        statValues.maxDistance = Math.max(statValues.maxDistance, distance);
        document.getElementById('minDistanceValue').innerText = statValues.minDistance.toFixed(2);
        document.getElementById('maxDistanceValue').innerText = statValues.maxDistance.toFixed(2);
        document.getElementById('r1Value').innerText = vars.r1.toFixed(2);
        document.getElementById('r2Value').innerText = vars.r2.toFixed(2);
    }

    bindEvents();
    setup();
    animate();


</script>

